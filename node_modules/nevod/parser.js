var fs = require("fs");

//file formats: 100Mhz, 200Mhz_notail, 200Mhz_tail
//hf (header format): 24b_f,  40b_f

const l_100_data = 2048*12*2; //main data length for 100 MHz, no tail
const l_24_header = 24; //24 bytes header length, no tail
const l_notail_ending = 4; //ending for no tail data

const l_200_data = 1024*12*2;
const l_tail_ending = 8;
const l_40_header = 40;
const l_tail = 20000*12*2;

const notail_ending = 'ffffffff';
const tail_ending = 'eeeeeeeeffffffff';

var chunkSize = 100000;
var packNum = 0;

var writeLog = function(msg,data1,data2){
	var time = new Date()
	var logstr = time+" :msg("+msg+")";
	if(data1){
		logstr+= "dataleft:(type:"+(typeof data1)+" class:"+data1.constructor.name+")";
	}
	if(data2){
		logstr+="buffer(type:"+(typeof data2)+" class:"+data2.constructor.name+")\n";
	} else {
		logstr+="\n"
	}
	fs.appendFileSync("./LOGFILE.dat",logstr)
}

module.exports = {
	parseFileByPart:function(filename,format,callback){
		packNum = 0
		fs.open(filename,'r',function(status,fd){
			if(status){
				console.error((new Date).toUTCString()+" PARSER "+status.message);
				fs.close(fd)
				return;
			}
			fs.stat(filename,function(err,stats){
				if(err){
					console.error((new Date).toUTCString()+" PARSER "+err)
					fs.close(fd)
					return;
				}
				var fileLength = stats.size, chunk = fileLength>chunkSize?chunkSize:fileLength, offset = fileLength - chunk,
					buffer = new Buffer(chunk);
				if(fileLength==0){
					fs.close(fd,function(){
						callback()
					})
					return
				}
				var readCallback = function(data){
					module.exports.parseBinaryFile(data,format,function(packs,dataleft,max_packs_length){
						if(packs==null || packs==undefined){
							callback()
						}
						var info = {
							status: 100-(offset*100/fileLength),
							finished:false,
							filestat:stats
						}
						if(offset == 0){
							fs.close(fd)
							info.finished=true;
							callback(packs,info);
							packs = null; info = null;
							return;
						}
						if(packs.length!=0){
							callback(packs,info)
							packs = null; info = null;
						}
						offset-=chunk;
						if(offset<0){ chunk-=offset*(-1); offset = 0; }
						var buffer = new Buffer(chunk)
						fs.read(fd,buffer,0,chunk,offset,function(err,bytesRead,buffer){
							if(err){
								console.error((new Date).toUTCString()+" PARSER "+err)
								fs.close(fd)
								return;
							}
							if(dataleft){
								readCallback(Buffer.concat([buffer,dataleft]))
								buffer = null; dataleft = null;
							} else {
								readCallback(buffer)
								buffer = null;
							}
						})
					},fileLength);
					data = null;
				};
				fs.read(fd,buffer,0,chunk,offset,function(err,bytesRead,buffer){
					if(err){
						fs.close(fd)
						console.error((new Date).toUTCString()+" PARSER "+err)
						return;
					}
					readCallback(buffer)
					buffer = null;
				})
				buffer = null;
			})
		});
	},
	parseBinaryFile:function(data,format,callback,fileLength){
		var fileformat = {
			l_data:l_100_data,
			l_header:l_24_header,
			l_ending:l_notail_ending,
			l_tail:0,
			packagelength:l_100_data+l_24_header+l_notail_ending,
			ending:notail_ending,
			hf:"",
			sig_type:"no signal",
			packCount: 1000
		};
		if (data == undefined) { console.error((new Date).toUTCString()+" parser, no data"); return; }
		switch (format) {
			case "100Mhz":
				fileformat.hf = "24b_f"
				fileformat.sig_type = "100Mhz_signal"
				break;
			case "200Mhz_tail":
				fileformat.l_data = l_200_data;
				fileformat.l_header = l_40_header;
				fileformat.l_ending = l_tail_ending;
				fileformat.l_tail = l_tail;
				fileformat.packagelength = l_200_data+l_40_header+l_tail_ending+l_tail;
				fileformat.ending = tail_ending;
				fileformat.hf = "40b_f";
				fileformat.sig_type = "200MhzTail_signal";
				fileformat.packCount = 50;
				break;
			case "200Mhz_notail":
				fileformat.hf = "24b_f";
				fileformat.sig_type = "200Mhz_notail";
				fileformat.l_data = l_200_data;
				fileformat.packagelength = l_200_data+l_24_header+l_notail_ending
				break;
			default:
				console.error((new Date).toUTCString()+" parser, wrong format");
				callback()
				return;
		}
		if(fileLength<fileformat.packagelength){
			callback()
			return
		}
		var packages = [];
		while (data.length >= fileformat.packagelength) {
			var ending = data.slice(data.length-fileformat.l_ending,data.length);
			if (ending.toString('hex')==fileformat.ending){
				var header = data.slice(data.length-fileformat.packagelength+fileformat.l_tail,data.length-fileformat.packagelength+fileformat.l_tail+fileformat.l_header);
				var p_data = data.slice(data.length-fileformat.l_data-fileformat.l_ending,data.length-fileformat.l_ending);
				var tail = [];
				if(fileformat.l_tail!=0){
					tail = data.slice(data.length-fileformat.packagelength,data.length-fileformat.packagelength+fileformat.l_tail);
				}
				data = data.slice(0,data.length-fileformat.packagelength);
				p_data = parsePackageData(p_data,tail);
				tail = [];
				var packageObj = {
					type:fileformat.sig_type,
					signal:p_data[0],
					time:parseHeader(header,fileformat.hf),
					number:packNum
				}
				packNum++
				if(fileformat.l_tail!=0){
					packageObj.tail = p_data[1];
				}
				packages.push(packageObj)
			} else {
				data = data.slice(0,data.length-1);
			}

			if(packages.length>=fileformat.packCount){
				// writeLog("parse overflow event")
				callback(packages,data,fileformat.packCount,false);
				packages = []
			}
		}
		if(data.length!=0){
			// writeLog("parse finished event,data left",data)
			callback(packages,data,fileformat.packCount,true);
		} else {
			callback(packages,null,fileformat.packCount,true);
		}
	}
}

var parsePackageData = function(p_data,tail) {
	try {
		var array = new Array(12).fill([]);
		var tailarray = new Array(12).fill([]);
		for (var i=0;i<p_data.length;i+=2){
			array[p_data[i+1]>>4].push((p_data[i+1]%0b10000)*0b100000000 + p_data[i])
		}
		if(tail.length!=0){
			for (var i=0;i<tail.length;i+=2){
				tailarray[tail[i+1]>>4].push((tail[i+1]%0b10000)*0b100000000 + tail[i])
			}
		}
		return [array,tailarray];
	} catch (e){
		console.error((new Date).toUTCString()+" PARSER_ERROR_Packs: "+e);
	}
}

var parseHeader = function(header,hf) {
	var d_time = new Buffer(8);
	switch (hf) {
		case "24b_f":
			d_time = header.slice(12,20);
			break;
		case "40b_f":
			d_time = header.slice(8,16);
			break;
		default:
			console.error((new Date).toUTCString()+" parser, wrong header format");
	}

	var ns = d_time[0]%0b10000000;
	var mks = (d_time[2]%0b10)*0b1000000000 + d_time[1]*0b10 + d_time[0]/0b10000000 | 0;
	var ms = (d_time[3]%0b1000)*0b10000000 + d_time[2]/0b10 | 0;
	var s = (d_time[4]%0b10)*0b100000 + d_time[3]/0b1000 | 0;
	var min =  (d_time[4]%0b10000000)/0b10;
	var hour = (d_time[5]%0b10000)*0b10 + d_time[4]/0b10000000 | 0;
	var day = (d_time[6]%0b100)*0b10000 + d_time[5]/0b10000 | 0;
	var time = [Math.floor(day),Math.floor(hour),Math.floor(min),Math.floor(s),Math.floor(ms),Math.floor(mks),Math.floor(ns*10)];
	return time;
}

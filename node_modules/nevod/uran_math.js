/**
 * @author Alexander Lakhonin (ixav1@icloud.com)
 * Модуль с математическими функциями для обработки данных с установок УРАН и НЕВОД-ШАЛ
 * @module uran_math.js
 */

'use strict'

/**
 * стандартное значение смещения от максимума, используется в функции charge_ratio
 * @type {Number}
 */
const CHARGE_OFFSET_DEFAULT = 110;

/**
 * значение при привыщении которого считается пик производной
 * @type {Number}
 */
const DER_WIDTH_TRESHOLD = 0.1;

module.exports = {
	/**
	 * функция для определения среднего значения массива
	 * @param  {Array} 
	 * @return {Number} 
	 */
	avarage:function(array) {
		try {
			var sum = 0.0;

			for (var i = 0; i < array.length; i++) {
				sum += array[i];
			}

			return sum/array.length;
		} catch(e) {
			console.error("UMATHERR_AVG: " + e);
		}
	},
	/**
	 * @param  {Array}
	 * @return {Number}
	 */
	max_of_array:function(array) {
		return Math.max.apply(null,array);
	},
	/**
	 * @param  {Array}
	 * @return {Number}
	 */
	min_of_array:function(array) {
		return Math.min.apply(null,array);
	},
	/**
	 * функция для сглаживания методом скользящего среднего
	 * @param  {Array} массив который необходимо сгладить
	 * @param  {Number} степень сглаживания
	 * @return {Array} сглаженный массив
	 */
	simple_moving_avarage:function(array,n) {
		try {
			let sma = [];

			for (var i = 0; i < array.length; i++) {
				var sum = array[i];
				var devide = 1;

				for (var j = 1; j <= n; j++) {
					if (array[i+j] !== undefined) {
						sum += array[i+j];
						devide++;
					}

					if (array[i-j] !== undefined) {
						sum+=array[i-j];
						devide++;
					}
				}

				var avg = sum/devide;
				sma.push(avg);		
			}

			return sma;
		} catch(e) {
			console.error("UMATHERR_SMA: " + e);
		}
	},
	/**
	 * функция значение максимального заряда и зарада в точке с заданным смещением от максимального заряда
	 * @param  {Array} осцилограмма сигнала
	 * @param  {Number} смещение от максимального заряда
	 * @param  {Number} максимальное значения сигнала, рекомендуется передовать если уже посчитано, если нет считается из передаваемого массива
	 * @return {Array} 0 - значение максимума, 1 - значение в точке смещения
	 */
	charge_ratio:function(array,offset,max) {
		try {
			max = max === undefined ? this.max_of_array(array) : max;
			offset = offset === undefined ? CHARGE_OFFSET_DEFAULT : offset;

			if (max<0) {
				return [-1,-1];
			}

			let maxPos = 0;

			for (var i = 0; i < array.length; i++) {
				if (array[i] == max) {
					maxPos = i;
					break;
				}
			}

			let val = maxPos <= offset ? 0 : array[maxPos-offset];
			val = val < 0 ? 0 : val;
			return[max,val];
		} catch (e) {
			console.error("UMATHERR_CHR: " + e);
		}
	},
	/**
	 * функция для нахождения производной по заданному массиву точек
	 * @param  {Array} массив точек
	 * @return {Array} производная
	 */
	derivative:function(array) {
		try {
			let der = [];

			for (var i = 0; i < array.length; i++) {
				if (i == array.length-1) {
					continue;
				} else {
					der.push(array[i+1] - array[i])
				}
			}

			return der;
		} catch (e) {
			console.error("UMATHERR_DER: " + e);
		}
	},
	/**
	 * функция определеяюшая ширину производной, если в производной два пика, возвращает наибольший
	 * @param  {Array} производная
	 * @param  {Number} порог превышения
	 * @return {Number} ширина пика производной
	 */
	derivativeWidth:function(der){ 
		try {
			let info = [], x1 = 0, x2 = 0, isHillFound = false;

			for (var i = 0; i < der.length; i++) {
				var y = der[i];

				if (y >= DER_WIDTH_TRESHOLD && !isHillFound) {
					x1 = i;
					isHillFound = true;
				}

				if (y < 0 && isHillFound) {
					x2 = i;
					isHillFound = false;
					info.push(x2 - x1);
					x2 = 0, x1 = 0;
				}
			}

			return this.max_of_array(info);
		} catch (e) {
			console.log("UMATHERR_DERW: " + e);
		}
	},
	/**
	 * создает пустой (заполненный нулями) массив спектров
	 * @param  {Number} length 
	 * @return {Array[][]}        спектры для 12 каналов
	 */
	createEmptySpArray:function(length) {
		var sp = [[],[],[],[],[],[],[],[],[],[],[],[]];

		for (var i = 0; i < length; i++) {
			for (var j = 0; j < 12; j++) {
				sp[j].push(0);
			}
		}

		return sp;
	},
	/**
	 * суммирует два спектра, спектры должны быть одинаковой длины
	 * @param {Array} sp1 
	 * @param {Array} sp2 
	 * @return {Array}
	 */
	addTwoSpectrums:function(sp1, sp2) {
		for (var i = 0; i < sp1[0].length; i++) {
			for (var j = 0; j < 12; j++) {
				sp1[j][i] += sp2[j][i];
			}
		}

		return sp1;
	}
}

